---
title: "Why Is Spatially Explicit Discretization Necessary?"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{whysed}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.path = "man/figures/whysed/",
  fig.dpi = 150
)
```


We use simulated data comprising 225 cells organized in a 15-row by 15-column grid to illustrate the rationale for employing spatially explicit discretization methods. We pre-constructed a grid-based simulated dataset with three strata, and then simulated Y under different spatial autocorrelation scenarios to explore the differences between explicit spatial discretization and implicit spatial discretization. The simulation of spatial data is conducted using the `spdgp` package in R. We selected hierarchical clustering with spatial constraints and hierarchical clustering method to represent explicit and implicit spatial discretization, respectively. The hierarchical clustering with spatial constraints and hierarchical clustering methods were implemented using the `ClustGeo` package. In subsequent analyses, all discretization methods applied will discretize the dataset into three strata for the calculation of the q-values.

## Install Necessary R Packages

```r
install.packages(c("sf","terra","sdsfun","gdverse"),dep = TRUE)
# install.packages("devtools")
devtools::install_github("ausgis/sesp",build_vignettes = TRUE,dep = TRUE)
# install.packages("pak")
pak::pak("josiahparry/spdgp")
```

## Simulated Independent Strata X

```{r x_strata,fig.width=3.75,fig.height=3,fig.cap=knitr::asis_output("**Figure 1**. Strata of simulated independent variable X")}
m = matrix(2,nrow = 15, ncol = 15)
zone1_indice = c(6:9,seq(8,by = -1,length.out = 6))
for (i in seq_along(zone1_indice)) {
  m[seq(1,zone1_indice[i]),i] = 1
}
m[,11:15] = 3
m[13,11] = 2
m[14,11:12] = 2
m[15,11:13] = 2

library(sf)
library(terra)
r = terra::rast(m, crs = "EPSG:4326")
names(r) = 'simx_strata'
simx = sf::st_as_sf(terra::as.points(r))
simx

strata1 = tibble::tibble(
  x = c(0,0,3.5,10,10),
  y = c(15,9.5,6,12.5,15)
) |>
  sf::st_as_sf(coords = c("x","y"), crs = 4326) |>
  sf::st_combine() |>
  sf::st_cast("POLYGON")

strata2 = tibble::tibble(
  x = c(0,0,3.5,10,10,13.5),
  y = c(0,9.5,6,12.5,3.5,0)
) |>
  sf::st_as_sf(coords = c("x","y"), crs = 4326) |>
  sf::st_combine() |>
  sf::st_cast("POLYGON")

strata3 = tibble::tibble(
  x = c(15,15,10,10,13.5),
  y = c(0,15,15,3.5,0)
) |>
  sf::st_as_sf(coords = c("x","y"), crs = 4326) |>
  sf::st_combine() |>
  sf::st_cast("POLYGON")

strata = sf::st_sf(stratas = c(1,2,3),
                   geometry = do.call(c, list(strata1,strata2,strata3)))

ggplot2::ggplot() +
  ggplot2::geom_sf(data = strata, fill = 'transparent',
                   color = 'grey10', lwd = 0.75) +
  ggplot2::geom_sf(data = simx,
                   ggplot2::aes(color = factor(simx_strata))) +
  ggplot2::labs(color = 'Strata') +
  ggplot2::theme_void()
```

## A Monte Carlo simulation experiment demonstrating the necessity of spatial explicit discretization

The error term is specified as $\mu \sim \mathcal{N}(0, 0.1)$, and the corresponding $Y$ is simulated using the spatial durbin process. The autoregressive coefficients of X are set to twice the stratification levels, i.e., stratifications 1, 2, and 3 correspond to autoregressive coefficients of 2, 4, and 6, respectively. The spatial lag coefficient takes values from 0.05 to 0.95 with an interval of 0.05. For each spatial lag coefficient $\rho$, we randomly simulate 100 times.

```{r}
us = vector("list",100)
for (i in seq_along(us)) {
  us[[i]] = rnorm(nrow(simx),0,0.1)
}

rho = seq(0.05,0.95,by = 0.05)

lw = spdep::nb2listw(sdsfun::spdep_nb(simx),
                     style = "W",
                     zero.policy = TRUE)
```

```{r}
mc_simq = \(cores = 6){
  doclust = FALSE
  if (inherits(cores, "cluster")) {
    doclust = TRUE
  } else if (cores > 1) {
    doclust = TRUE
    cores = parallel::makeCluster(cores)
    on.exit(parallel::stopCluster(cores), add = TRUE)
  }

  paradf = tidyr::crossing("rho" = rho,
                           "ui" = 1:100)
  parak = split(paradf, seq_len(nrow(paradf)))

  gdist = stats::as.dist(sdsfun::sf_distance_matrix(simx))
  hclustgeo_disc = \(xv,alpha = 0.5){
    D0 = stats::dist(xv)
    resh = ClustGeo::hclustgeo(D0,gdist,alpha = alpha)
    return(stats::cutree(resh,3))
  }

  calcul_q = \(paramgd){
    rhov = paramgd[[1]]
    u_i = paramgd[[2]]
    y = spdgp::sim_durbin(us[[u_i]], simx$simx_strata*2, simx$simx_strata, lw, rho = rhov)
    sed = hclustgeo_disc(y,alpha = 0.5)
    sid = hclustgeo_disc(y,alpha = 0)
    qv1 = gdverse::factor_detector(y,sed)[[1]]
    qv2 = gdverse::factor_detector(y,sid)[[1]]
    res = tibble::tibble(qv_sed = qv1, qv_sid = qv2,
                         qv_bias = qv1 - qv2,rho = rhov)
    return(res)
  }

  if (doclust) {
    parallel::clusterExport(cores, varlist = c("simx","us","rho","lw"))
    out_g = parallel::parLapply(cores,parak,calcul_q)
    out_g = tibble::as_tibble(do.call(rbind, out_g))
  } else {
    out_g = purrr::map_dfr(parak,calcul_q)
  }
  return(out_g)
}

qv = mc_simq(cores = 12)
qv
```
